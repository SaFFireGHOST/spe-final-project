pipeline {
  agent any

  environment {
    DOCKERHUB_CREDS = credentials('dockerhub-creds')
    REGISTRY = "docker.io/${DOCKERHUB_CREDS_USR}"
    IMAGE_TAG = "${env.BUILD_NUMBER}"
    PYTHON_VERSION = "3"
    // Point to the user's kubeconfig so Jenkins deploys to the SAME cluster
    KUBECONFIG = "/home/harsh2835/.kube/config"
  }

  triggers {
    githubPush()
    pollSCM('H/5 * * * *')
  }

  options {
    ansiColor('xterm')
    timestamps()
    disableConcurrentBuilds()
    skipDefaultCheckout()
    buildDiscarder(logRotator(numToKeepStr: '25'))
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Setup Python') {
      steps {
        sh "python${PYTHON_VERSION} -m venv .venv"
        sh ". .venv/bin/activate && pip install --upgrade pip wheel"
        sh ". .venv/bin/activate && pip install -e ."
        // Ansible installation removed
      }
    }

    stage('Linting') {
      steps {
        sh ". .venv/bin/activate && pip install flake8"
        sh ". .venv/bin/activate && flake8 services common gateway.py --count --select=E9,F63,F7,F82 --show-source --statistics"
      }
    }

    stage('Unit Tests') {
      steps {
        sh ". .venv/bin/activate && python3 -m pytest --maxfail=1 --disable-warnings -q || true"
      }
    }

    stage('Frontend Tests') {
      steps {
        dir('frontend') {
          sh "docker build -t temp-frontend-test -f Dockerfile ."
        }
      }
    }

    stage('SAST & Secret Scan') {
      steps {
        sh ". .venv/bin/activate && pip install bandit pip-audit"
        sh ". .venv/bin/activate && bandit -r services common gateway.py -c bandit.yml"
        sh "gitleaks detect -c .gitleaks.toml --no-banner || true"
        sh ". .venv/bin/activate && pip-audit || true"
      }
    }

    stage('Build Images') {
      steps {
        script {
          def changedServices = getChangedServices()
          echo "Services to build: ${changedServices}"
          
          if (changedServices.isEmpty()) {
            echo "No services changed. Skipping build."
          } else {
            def builds = [:]
            
            // Map service names to their Dockerfiles
            def svcFiles = [
              'user-svc': 'Dockerfile.user',
              'station-svc': 'Dockerfile.station',
              'driver-svc': 'Dockerfile.driver',
              'rider-svc': 'Dockerfile.rider',
              'trip-svc': 'Dockerfile.trip',
              'notification-svc': 'Dockerfile.notification',
              'matching-svc': 'Dockerfile.matching',
              'location-svc': 'Dockerfile.location',
              'gateway-svc': 'Dockerfile.gateway'
            ]

            changedServices.each { name ->
              if (name == 'lastmile-frontend') {
                 builds['lastmile-frontend'] = {
                    sh "docker build -t ${REGISTRY}/lastmile-frontend:${IMAGE_TAG} -t ${REGISTRY}/lastmile-frontend:latest -f frontend/Dockerfile frontend"
                 }
              } else if (svcFiles.containsKey(name)) {
                 def dockerfile = svcFiles[name]
                 builds[name] = {
                    sh "docker build -f ${dockerfile} -t ${REGISTRY}/${name}:${IMAGE_TAG} -t ${REGISTRY}/${name}:latest ."
                 }
              }
            }
            
            parallel builds
          }
        }
      }
    }

    stage('Container Scan (Trivy)') {
      steps {
        script {
           def changedServices = getChangedServices()
           if (!changedServices.isEmpty()) {
               def scans = [:]
               
               changedServices.each { svc ->
                 // Skip frontend for Trivy scan if not configured or if you want to scan it too, add logic.
                 // Assuming we scan all built images.
                 scans[svc] = {
                   echo "Scanning ${svc}..."
                   sh "docker run --privileged --rm -u 0 -v /var/run/docker.sock:/var/run/docker.sock:z aquasec/trivy:latest image --severity HIGH,CRITICAL ${REGISTRY}/${svc}:${IMAGE_TAG} || true"
                 }
               }
               
               parallel scans
           }
        }
      }
    }

    stage('Push Images') {
      steps {
        script {
          def changedServices = getChangedServices()
          if (!changedServices.isEmpty()) {
              sh "echo $DOCKERHUB_CREDS_PSW | docker login -u $DOCKERHUB_CREDS_USR --password-stdin"
              
              def pushes = [:]
              
              changedServices.each { img ->
                pushes[img] = {
                  sh "docker push ${REGISTRY}/${img}:${IMAGE_TAG} && docker push ${REGISTRY}/${img}:latest"
                }
              }
              
              parallel pushes
          }
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')]) {
          script {
            // Apply all manifests to ensure cluster state is correct
            // This replaces Ansible
            sh "kubectl apply --validate=false -f k8s/"
            
            def changedServices = getChangedServices()
            if (!changedServices.isEmpty()) {
                def updates = [:]
                
                changedServices.each { svc ->
                  updates[svc] = {
                    if (svc == 'lastmile-frontend') {
                        sh "kubectl set image deployment/frontend frontend=${REGISTRY}/lastmile-frontend:${IMAGE_TAG} -n lastmile"
                    } else {
                        // For gateway, the container name is 'gateway' but image is 'gateway-svc'
                        // For others, usually container name matches service name or is slightly different.
                        // Based on previous Jenkinsfile: "deployment/${svc}" and container "${svc}"
                        // Except gateway: deployment/gateway, container gateway, image gateway-svc
                        
                        def deploymentName = (svc == 'gateway-svc') ? 'gateway' : svc
                        def containerName = (svc == 'gateway-svc') ? 'gateway' : svc
                        def imageName = svc // The image name we built
                        
                        sh "kubectl set image deployment/${deploymentName} ${containerName}=${REGISTRY}/${imageName}:${IMAGE_TAG} -n lastmile"
                    }
                  }
                }
                
                parallel updates
                
                // Wait for rollouts if they happened
                if (changedServices.contains('gateway-svc')) {
                    sh "kubectl rollout status deployment/gateway -n lastmile --timeout=180s"
                }
                if (changedServices.contains('lastmile-frontend')) {
                    sh "kubectl rollout status deployment/frontend -n lastmile --timeout=180s"
                }
            }
          }
        }
      }
    }
  }

  post {
    always {
      cleanWs()
    }
  }
}

// Helper function to detect changed services
def getChangedServices() {
    def allServices = ['user-svc', 'station-svc', 'driver-svc', 'rider-svc', 'trip-svc', 'notification-svc', 'matching-svc', 'location-svc', 'gateway-svc', 'lastmile-frontend']
    
    // Debugging: Print commit info
    echo "Current Commit: ${env.GIT_COMMIT}"
    echo "Previous Commit (Env): ${env.GIT_PREVIOUS_COMMIT}"

    def previousCommit = env.GIT_PREVIOUS_COMMIT
    
    // Fallback: If env var is missing, try to get the previous commit from git history
    if (previousCommit == null || previousCommit == '') {
        try {
            // Check if we have enough depth
            previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
            echo "Previous Commit (Git fallback): ${previousCommit}"
        } catch (Exception e) {
            echo "Could not determine previous commit via git: ${e.message}"
        }
    }

    // If still null, build all
    if (previousCommit == null || previousCommit == '') {
        echo "No previous commit found. Building all services."
        return allServices
    }

    def currentCommit = env.GIT_COMMIT
    if (currentCommit == null || currentCommit == '') {
        try {
            currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
            echo "Current Commit (Git fallback): ${currentCommit}"
        } catch (Exception e) {
            echo "Could not determine current commit: ${e.message}"
            return allServices
        }
    }

    try {
        def changedFiles = sh(script: "git diff --name-only ${previousCommit} ${currentCommit}", returnStdout: true).trim().split('\n')
        echo "Changed files: ${changedFiles}"
        
        def changedServices = [] as Set

        for (file in changedFiles) {
            if (file.startsWith('common/') || file == 'pyproject.toml') {
                echo "Shared code changed (${file}). Building all backend services."
                return allServices
            }
            
            if (file.startsWith('frontend/')) {
                changedServices.add('lastmile-frontend')
            } else if (file.startsWith('services/user_svc.py') || file == 'Dockerfile.user') {
                changedServices.add('user-svc')
            } else if (file.startsWith('services/station_svc.py') || file == 'Dockerfile.station') {
                changedServices.add('station-svc')
            } else if (file.startsWith('services/driver_svc.py') || file == 'Dockerfile.driver') {
                changedServices.add('driver-svc')
            } else if (file.startsWith('services/rider_svc.py') || file == 'Dockerfile.rider') {
                changedServices.add('rider-svc')
            } else if (file.startsWith('services/trip_svc.py') || file == 'Dockerfile.trip') {
                changedServices.add('trip-svc')
            } else if (file.startsWith('services/notification_svc.py') || file == 'Dockerfile.notification') {
                changedServices.add('notification-svc')
            } else if (file.startsWith('services/matching_svc.py') || file == 'Dockerfile.matching') {
                changedServices.add('matching-svc')
            } else if (file.startsWith('services/location_svc.py') || file == 'Dockerfile.location') {
                changedServices.add('location-svc')
            } else if (file == 'gateway.py' || file == 'Dockerfile.gateway') {
                changedServices.add('gateway-svc')
            }
        }
        
        return changedServices.toList()
    } catch (Exception e) {
        echo "Error detecting changes: ${e.message}. Fallback to building all."
        return allServices
    }
}
